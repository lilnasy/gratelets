From c923eb9e706e38fe0aaa53a174461be5a5c5a7aa Mon Sep 17 00:00:00 2001
From: Arsh <69170106+lilnasy@users.noreply.github.com>
Date: Sun, 22 Dec 2024 01:42:33 +0530
Subject: [PATCH 2/3] use implementation

---
 packages/integrations/cloudflare/src/index.ts | 75 ++++++++++++++++++-
 .../cloudflare/src/utils/handler.ts           | 44 ++++++++++-
 2 files changed, 115 insertions(+), 4 deletions(-)

diff --git a/packages/integrations/cloudflare/src/index.ts b/packages/integrations/cloudflare/src/index.ts
index abb3eb1435..1ca3ecd243 100644
--- a/packages/integrations/cloudflare/src/index.ts
+++ b/packages/integrations/cloudflare/src/index.ts
@@ -16,9 +16,9 @@ import type {
 	IntegrationResolvedRoute,
 } from 'astro';
 import { AstroError } from 'astro/errors';
-import type { PluginOption } from 'vite';
+import type { PluginOption, ViteDevServer } from 'vite';
 import { defaultClientConditions } from 'vite';
-import { type GetPlatformProxyOptions, getPlatformProxy } from 'wrangler';
+import { type GetPlatformProxyOptions, type PlatformProxy, getPlatformProxy } from 'wrangler';
 import {
 	type CloudflareModulePluginExtra,
 	cloudflareModuleLoader,
@@ -26,6 +26,7 @@ import {
 import { createGetEnv } from './utils/env.js';
 import { createRoutesFile, getParts } from './utils/generate-routes-json.js';
 import { type ImageService, setImageConfig } from './utils/image-config.js';
+import { handleUpgradeRequests } from './websocket/dev-middleware.js';
 
 export type { Runtime } from './utils/handler.js';
 
@@ -122,6 +123,53 @@ export type Options = {
 	};
 };
 
+export interface Locals {
+	/**
+	 * Whether the current request wants the connection to be upgraded
+	 * to a WebSocket.
+	 */
+    isUpgradeRequest: boolean
+    /**
+     * Upgrade an incoming HTTP request to a bidirectional WebSocket
+     * connection.
+     *
+     * Returns a pair of {@linkcode WebSocket} and {@linkcode Response}
+     * instances. The request must be responded to with the provided
+     * response for the provided WebSocket to open and start receiving
+     * messages from the browser.
+     *
+     * ```ts
+     * export const GET: APIRoute = ctx => {
+     *     if (ctx.locals.isUpgradeRequest) {
+     *         const { response, socket } = ctx.locals.upgradeWebSocket()
+     *         socket.onmessage = event => {
+     *             if (event.data === "ping") {
+     *                 socket.send("pong")
+     *             }
+     *         }
+     *         return response
+     *     }
+     *     return new Response("Upgrade required", { status: 426 })
+     * }
+     * ```
+     *
+     * Calling this function on its own does not connect the WebSocket.
+     * It only returns a pair of objects that will establish the connection
+     * once the generated response has been returned from the API Route.
+     *
+     * Throws if the request is not an upgrade request.
+     */
+    upgradeWebSocket(): { socket: WebSocket, response: Response };
+}
+
+interface NodeLocals extends Locals {}
+
+declare global {
+	namespace App {
+		export interface Locals extends NodeLocals {}
+	}
+}
+
 function wrapWithSlashes(path: string): string {
 	return prependForwardSlash(appendForwardSlash(path));
 }
@@ -150,6 +198,8 @@ export default function createIntegration(args?: Options): AstroIntegration {
 	let _routes: IntegrationResolvedRoute[];
 
 	const SESSION_KV_BINDING_NAME = args?.sessionKVBindingName ?? 'SESSION';
+	let viteDevServer: ViteDevServer;
+	let platformProxy: PlatformProxy;
 
 	return {
 		name: '@astrojs/cloudflare',
@@ -206,6 +256,15 @@ export default function createIntegration(args?: Options): AstroIntegration {
 								},
 							},
 						],
+						esbuild: {
+							tsconfigRaw: {
+								compilerOptions: {
+									// make the compilation of classes
+									// compatable with standard ES6
+									useDefineForClassFields: true,
+								}
+							}
+						},
 					},
 					image: setImageConfig(args?.imageService ?? 'compile', config.image, command, logger),
 				});
@@ -220,6 +279,12 @@ export default function createIntegration(args?: Options): AstroIntegration {
 					entrypoint: '@astrojs/cloudflare/entrypoints/middleware.js',
 					order: 'pre',
 				});
+				if (command === 'dev') {
+					addMiddleware({
+						entrypoint: new URL('./websocket/dev-middleware.ts', import.meta.url),
+						order: 'pre',
+					});
+				}
 			},
 			'astro:routes:resolved': ({ routes }) => {
 				_routes = routes;
@@ -272,8 +337,9 @@ export default function createIntegration(args?: Options): AstroIntegration {
 				});
 			},
 			'astro:server:setup': async ({ server }) => {
+				viteDevServer = server;
 				if ((args?.platformProxy?.enabled ?? true) === true) {
-					const platformProxy = await getPlatformProxy(args?.platformProxy);
+					platformProxy = await getPlatformProxy(args?.platformProxy);
 
 					// Ensures the dev server doesn't hang
 					server.httpServer?.on('close', async () => {
@@ -308,6 +374,9 @@ export default function createIntegration(args?: Options): AstroIntegration {
 					});
 				}
 			},
+			'astro:server:start'() {
+				handleUpgradeRequests(viteDevServer, platformProxy);
+			},
 			'astro:build:setup': ({ vite, target }) => {
 				if (target === 'server') {
 					vite.resolve ||= {};
diff --git a/packages/integrations/cloudflare/src/utils/handler.ts b/packages/integrations/cloudflare/src/utils/handler.ts
index 28434717d6..fbb6b5f0b3 100644
--- a/packages/integrations/cloudflare/src/utils/handler.ts
+++ b/packages/integrations/cloudflare/src/utils/handler.ts
@@ -9,6 +9,7 @@ import type { SSRManifest } from 'astro';
 import type { App } from 'astro/app';
 import { setGetEnv } from 'astro/env/setup';
 import { createGetEnv } from '../utils/env.js';
+import type { Locals } from '../index.js';
 
 type Env = {
 	[key: string]: unknown;
@@ -17,6 +18,16 @@ type Env = {
 
 setGetEnv(createGetEnv(globalEnv as Env));
 
+/**
+ * Cloudflare workers do not fire the open event. This results
+ * in interop issues with the other runtimes.
+ *
+ * The server websocket is tracked in this so that - when the
+ * corresponding response is returned - the open event can be
+ * dispatched on it.
+ */
+const responseToSocketMap = new WeakMap<Response, WebSocket>()
+
 export interface Runtime<T extends object = object> {
 	runtime: {
 		env: Env & T;
@@ -68,7 +79,24 @@ export async function handle(
 
 	Reflect.set(request, Symbol.for('astro.clientAddress'), request.headers.get('cf-connecting-ip'));
 
-	const locals: Runtime = {
+	const locals: Runtime & Locals = {
+		get isUpgradeRequest() {
+			return request.headers.get("upgrade") === "websocket";
+		},
+		upgradeWebSocket() {
+			// @ts-expect-error modifiers can appear here
+			declare const WebSocketPair: typeof import("@cloudflare/workers-types").WebSocketPair;
+			const { 0: clientWs, 1: serverWs } = new WebSocketPair();
+			const response = new Response(null, {
+				status: 101,
+				// @ts-expect-error Cloudflare extends Response with a webSocket property
+				webSocket: clientWs,
+			});
+			// @ts-expect-error Cloudflare's WebSocket is missing some properties
+			const socket: WebSocket = serverWs;
+			responseToSocketMap.set(response, socket);
+			return { response, socket };
+		},
 		runtime: {
 			env: env,
 			cf: request.cf,
@@ -97,6 +125,20 @@ export async function handle(
 		},
 	);
 
+	const socket = responseToSocketMap.get(response)
+	if (socket) {
+		// @ts-expect-error Cloudflare's extends WebSocket with an accept
+		// method that must be called before the socket can be used.
+		// In our API, returning the upgrade response from an API route
+		// or the page implies accepting the WebSocket connection.
+		socket.accept()
+		// @ts-expect-error This listener should exist to avoid
+		// "script will never generate a response" errors, but for some
+		// reason, they happen anyway in workerd.
+		socket.addEventListener("close", e => e.currentTarget.close())
+		socket.dispatchEvent(new Event("open"))
+	}
+
 	if (app.setCookieHeaders) {
 		for (const setCookieHeader of app.setCookieHeaders(response)) {
 			response.headers.append('Set-Cookie', setCookieHeader);
-- 
2.50.1

